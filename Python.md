## [Сокращение кода на Python для acmp.ru](http://iqbotan.blogspot.ru/2016/06/python-acmp.html)

### Предисловие

Прежде чем перейти к способам сокращения кода на Python, требуется обговорить ряд моментов.

1. На acmp используется CPython 3.4.3. Далее под Python я буду подразумевать именно эту реализацию Python.
2. Python является интерпретируемым языком. Это даёт ему мощь и краткость, однако из-за этого он работает ГОРАЗДО медленнее. Если для C++ примерной оценкой производительности является 10<sup>9</sup> операций в секунду, то Python осуществляет примерно 10<sup>7</sup> операций в секунду. Более того, Python фактически не производит оптимизаций и при написании эффективного кода необходимо знать некоторые принципы. Поэтому сдать некоторые задачи на Python фактически невозможно.
3. Несущественные фрагменты кода (например, тела циклов) будут опускаться, вместо них будут писаться многоточие. 
4. Сокращение кода обычно приводит к очень плохому коду: не используйте приёмы сокращения в нормальном программировании!

### Общие советы
В [прошлой статье](http://iqbotan.blogspot.ru/2012/12/c-acmp.html) я описал несколько приёмов, применимых также и для Python. Большая часть их достаточно очевидна, поэтому не буду их повторять. Разве что хотелось бы напомнить о битовой арифметике (возможно, позже я даже добавлю о ней пункт и в эту статью). А вот некоторые общие советы я всё же повторю. 

1. Основой кратчайшего кода является кратчайший алгоритм. Иногда этот кратчайший алгоритм может быть значительно медленнее, чем оптимальный, что особенно критично для Python.
2. Не следует переусложнять свой код: никаких классов и лишних функций, никаких промежуточных переменных и комментариев, никаких `__main__` и других общепринятых способов грамотного оформления кода. Отличным примером сокращенного кода является код, приведенный в примере на acmp:
    ```python
    print(sum(map(int, input().split())))
    ```
    В нем нет ни одной переменной!
3. Используйте однобуквенные переменные. Их у вас как минимум 53: 26 строчных латинских букв, 26 заглавных латинских букв и `_` (символ подчеркивания). Однако переменную `_` удобно использовать в случаях, когда присваиваемое/возвращаемое значение требуется проигнорировать: IDE не будет выдавать надоедливое предупреждение о неиспользованной переменной. В примерах я буду использовать её именно в таких случаях.
4. Обращайте внимание на [приоритеты операторов](https://docs.python.org/3.4/reference/expressions.html#operator-precedence). Например, приоритет оператора `and` выше приоритета оператора `or`.
5. В питоне очень много встроенных функций и типов, которые можно использовать без импорта библиотек. Обязательно просмотрите [встроенные функции](https://docs.python.org/3.4/library/functions.html) и [методы встроенных типов](https://docs.python.org/3.4/library/stdtypes.html) (особое внимание уделите методам строк (`str`) и списков (`list`)).

### Разное полезное

#### 1 Стандартная библиотека
В Python достаточно богатая стандартная библиотека, всегда пробуйте найти в ней решения каких-то стандартных задач. Модули, которые мне доводилось использовать:

1. `re` - для работы с регулярными выражениями. В Python регулярные выражения иногда являются наиболее простым и кратким способом распарсить строку либо просто что-то с ней сделать.
2. `math` - математические функции, а также числа `pi` и `e`.
3. `datetime` - работа с датами и временем.
4. `fractions` - работа с рациональными числами. Содержит функцию вычисления НОД - `gcd`.
5. `itertools` - содержит функции генерации перестановок, сочетаний и всего такого.

К сожалению, в Python нет встроенного модуля для работы с отсортированными множествами, вместо этого предлагается использовать модули `heapq` (очередь с приоритетами) и `bisect` (бинарный поиск).

#### 2 Длинная арифметика
В тип `int` встроена длинная арифметика, то есть над ним можно производить любые преобразования, не боясь вылететь за границы типа.  
Однако тип `float` представляет собой обычные числа с плавающей запятой двойной точности (`double` в си-подобных языках), поэтому при преобразовании `int` в `float` длинная арифметика теряется (вплоть до того, что значение `int` может не влезть в `float`, в таком случае вылетает исключение). Для решения этой проблемы можно использовать `decimal` (числа с фиксированной запятой) или `fractions` (рациональные числа).

#### 3 Операторы `/`, `//`, `%`
Оператор `/` выполняет вещественное деление, возвращая `float` даже если аргументами были `int`:
```python
10 / 4 == 2.5
11.5 / 2.5 == 4.6
4 / 2 == 2.0
```
Оператор `//` выполняет целочисленное деление, округляя результат. Если аргументами оператора `//` являются `float`, тогда результат тоже имеет тип `float`, но округление все равно происходит.
```python
10 // 4 == 2
10.0 // 4.0 == 2.0
11.5 // 2.5 == 4.0
```
Оператор `%`, возвращающий остаток от деления, ведет себя аналогично:
```python
10 % 4 == 2
10.0 % 4.0 == 2.0
11.5 % 2.5 == 1.5
```

Эти операторы могут быть использованы для работы с `float`:
```python
x // 1 # возвращает целую часть числа
x % 1 # возвращает дробную часть числа
```
К сожалению, как было сказано ранее, результатами этих операций также будет являться `float`, что зачастую неприемлемо (например, при выводе результата через `print`).

В Python для целочисленного деления используется математическое определение (округление вниз, остаток неотрицателен) вместо принятого в си-подобных языках деления с округлением в сторону нуля. Разница появляется только на отрицательных числах:
```python
-15 // 4 == -4 # в си-подобных языках -3
-15 % 4 == 1 # в си-подобных языках -3
```
Эту особенность можно использовать для реализации деления с округлением вверх:
```python
(n+k-1)//k # 10 символов
-n//k*-1 # 8 символов
```

#### 4 Строковые литералы
Строки могут быть записаны как с помощью одиночных кавычек (`'`), так и двойных (`"`) - они равнозначны:
```python
'abc' == "abc"
```
Если в строке присутствуют кавычки, то их не придется экранировать, если для записи строки использовать другие кавычки:
```python
"What's your name?" == 'What\'s your name?'
```

Регулярные выражения часто содержат много слэшей, которые приходится экранировать:
```python
"(\\w)(\\w+)(\\w)"
```
Для таких случаев в Python есть raw strings - в них слэш интерпретируется как обычный символ, а не как символ экранирования:
```python
r"(\w)(\w+)(\w)"
```

Если требуется вывести несколько строк, то может быть удобно использовать многострочные строки:
```python
"""One string
Second string
Third string"""
```
Это эквивалентно
```python
"One string\nSecond string\nThird string"
```
В многострочных строках можно использовать одинарные и двойные кавычки без экранирования (за исключением удивительного случая, когда потребуется три кавычки подряд, да еще и именно тех, которые открывают строку). 

#### 5 Проверка на истинность
В Python все переменные могут быть проверены на истинность (использованы в логическом контексте, например, в условии `if` или `while`):

1. Число ложно, если оно равно `0`.
2. Строка (`str`) ложна, если она пуста, то есть равна `""`. 
3. Коллекция ложна, если она пуста. Ко встроенным коллекциям относятся списки (`list`), кортежи (`tuple`), множества (`set`) и словари (`dict`).

Например, вместо
```python
while s>0:
    ...
    s -= 1
```
можно написать просто
```python
while s:
    ...
    s -= 1
```

#### 6 Логические операторы
В Python операторы `and` и `or` имеют необычное поведение:
```python
x or y # если x истинно, то возвращает x, иначе y
x and y # если x истинно, то возвращает y, иначе x
```
Иногда это мешает, а иногда может быть использовано при сокращени. Например, через них можно реализовать условный оператор:
```python
x if c else y # 9 символов
c and x or y # 8 символов
```
К сожалению, эта конструкция работает некорректно, если `x` ложно.  
Пользуясь также тем, что приоритет оператора `and` выше приоритета оператора `or`, можно конструировать нечто похожее на `switch` из си-подобных языков:
```python
x>0 and 1 or x<0 and 2 or 'NO'
```

Операторы `and` и `or` являются ленивыми, то есть второй операнд не вычисляется, если достаточно первого.  
Благодаря этому вместо
```python
if y == 0: print(x)
```
можно написать
```python
y or print(x)
```
Тут следует пояснить, что функции, которые ничего не возвращают (например, `print`), на самом деле возвращают специальный объект `None` (который всегда ложен).

Некоторые функции, например, `min`, выбрасывают исключение, если передать им пустую коллекцию. Чтобы отловить такую ситуацию, вместо явной проверки на пустоту можно использовать оператор `or`:
```python
min(s) if s else -1 # 15 символов
min(s or [-1]) # 12 символов
```
Если в коллекции `s` что-то есть, то оператор `or` передаст в функцию `min` именно её. Если же она пуста, то `or` передаст в `min` список `[-1]`, минимум которого равен `-1`.

#### 7 Логические значения как числа
Класс `bool` унаследован от класса `int`, а `True` и `False` равны `1` и `0` соответственно. Единственным их отличием от чисел является переопределенный метод преобразования в строку (чтобы получалось `"True"` вместо `"1"`).  
Во всех остальных случаях можно использовать `bool` как `int`. Например, вместо
```python
if x>0: s += 1 # 10 символов
```
можно написать
```python
s += x>0 # 6 символов
```

Этот приём также используется для реализации функции `cmp`:
```python
(a>b)-(a<b) # 1, если a>b; 0, если a == b; -1, если a<b
```

В некоторых задачах возникает необходимость вывести `-1`, если некоторое условие не выполняется:
```python
a<0 and x or -1 # 11 символов
```
Это можно записать короче:
```python
-(a>=0) or x # 10 символов
```
Аналогично, пример из предыдущего пункта может быть сокращен на один символ заменой `x>0 and 1` на `+(x>0)`.

#### 8 Операторы сравнения
Операторы сравнения (`<`, `>`, `==`, `<=`, `>=`, `!=`, `in`, `not in`, `is`, `not is`) могут быть сцеплены в одну конструкцию, например, `0 < a < b < c`. Эта конструкция эквивалентна `0 < a and a < b and b < c` за тем исключением, что переменные `a` и `b` появляются и вычисляются всего один раз (а значит можно писать `0 < int(input()) < 3`).

Сцепку сравнений можно использовать для избавления от оператора `and`:
```python
x > 0 and y > 0 # 9 символов
x > 0 < y # 5 символов

x > 2 and y > 4 # 9 символов
x > 2 < 4 < y # 7 символов
```

Сцепка операторов является ленивой и выполняется слева направо до тех пор, пока результат не станет ясен. Это позволяет использовать её в качестве условного оператора: например, вместо
```python
if x < y: print(z) # 14 символов
```
можно написать
```python
x < y is print(z) # 13 символов
```
Сравнение `y is print(z)`, а значит и сама функция `print(z)`, вызовется только в том случае, если `x<y`. Ну а оператор `is` определен для любых объектов, включая возвращаемый функцией `print` объект `None`, поэтому эта конструкция не вызывает `Runtime Error`.

#### 9 Циклы
При написании циклов в Python принято использовать `range`:
```python
for i in range(n):
    ...
# 15 символов
```
В приведенном примере `i` пробегает от `0` до `n-1`. Однако такой вариант требуется далеко не всегда. Очень часто индекс текущей итерации вообще не нужен либо допустим убывающий порядок индексов. В таких случаях выгодно написать цикл вручную через `while`. Рассмотрим несколько распространенных случаев.

1. Цикл `i = 1...n`.  
    С `range`: 
    ```python
    for i in range(1, n+1):
        ...
    # 19 символов
    ```
    Вручную:
    ```python
    i = 0
    while i<n:
        i += 1
        ...
    # 16 символов
    ```

2. Цикл `i = n...1`.  
    С `range`: 
    ```python
    for i in range(n, 0, -1):
        ...
    # 20 символов
    ```
    Вручную:
    ```python
    i = n
    while i:
        ...
        i -= 1
    # 14 символов
    ```

3. Цикл `i = n-1...0`.  
    С `range`: 
    ```python
    for i in range(n-1, -1, -1):
        ...
    # 23 символа
    ```
    Вручную:
    ```python
    i = n
    while i:
        i -= 1
        ...
    # 14 символов
    ```

Во 2 и 3 случаях если после цикла больше нигде не требуется переменная `n`, то можно не тратить три символа на создание переменной `i`, а итерироваться непосредственно с помощью переменной `n`.

#### 10 Умножение на число
В Python для многих типов определена операция умножения на число:
```python
"abc" * 3 == "abcabcabc"
[1, 2, 3] * 2 == [1, 2, 3, 1, 2, 3]
(1, 2, 3) * 2 == (1, 2, 3, 1, 2, 3)
```
Что приятно, при умножении на отрицательное число получается просто пустая коллекция.  
Есть два классических примера применения данного приёма:

1. Иногда требуется создать копию списка, однако списки в Python являются ссылочными типами и операция `y=x` не создает копию списка: переменные `x` и `y` просто будут указывать на один и тот же список. Операция умножения на число решает эту проблему: `y=x*1`.
2. Пусть нам требуется осуществить `n` однотипных итераций, например, прочитать `n` строк, причем нам не требуется знать номер текущей итерации. Из уже известных из предыдущего пункта способов кратчайшим является убывающий цикл:
    ```python
    while n:
        ...
        n -= 1
    # 11 символов
    ```
    Однако в этом случае мы портим переменную `n` и если этого необходимо этого избежать, приходится тратить еще 3 символа на создание временной переменной. Операция умножения на число позволяет избежать этой проблемы:
    ```python
    for _ in ' ' * n:
        ...
    # 11 символов
    ```
    Если необходимо проделать `2*n` итераций, то вместо естественного `' ' * 2*n` можно написать <code>'&nbsp;&nbsp;'*n</code>.  
    Иногда бывают случаи, когда `n` заранее известно. В этом случае можно сократить код еще сильнее. Например, следующий код проделает ровно 4 итерации:
    ```python
    for _ in '    ':
        ...
    # 9 символов
    ```

#### 11 Цикл с индексом
Иногда требуется пройтись по строке/списку в цикле, зная при этом индекс текущего элемента. В Python это принято делать так:
```python
for i, x in enumerate(m):
    ...
# 21 символов
```
Но можно сделать гораздо короче:
```python
i = 0
for x in m:
    ...
    i += 1
# 15 символов
```

#### 12 Условный оператор
Python предлагает нам ужасно многословный ~~тернарный~~ условный оператор:
```python
x if c else y # 9 символов
```
Есть несколько вариантов решения проблемы.

1.  ```python
    c and x or y # 8 символов
    ```
    Как упоминалось ранее, этот вариант не работает, если `x` может быть ложно.
2.  ```python
    [y,x][c] # 8 символов
    ```
    Этот вариант работает только если `c` является логическим выражением или числом `0/1`.
3.  ```python
    c*x or y # 6 символов
    ```
    Переменная `x` должна быть истинна, для неё должно быть определено умножение на число (то есть она должна быть числом, строкой, списком или кортежем), а переменная `c` должна быть числом `0/1` либо булевой переменной, что получается крайне редко. При попытке использовать вместо `c` логическое выражение возникает необходимость поставить вокруг него скобки, что увеличивает количество символов до 8.  
    Есть несколько случаев, когда данную проблему можно решить: если известно, что `n` - целое положительное число, то условие `n==1` можно заменить на `1//n`, а условие `n>1` - на `1%n`; если `n` - неотрицательное число, то условие `n==0` можно заменить на `0**n`.

#### 13 Немного теории: итераторы и итерируемые объекты
Итератор - это объект, который последовательно возвращает некоторые элементы. Итерируемый объект (iterable) - это объект, у которого мы можем получить итератор. Другими словами, итерируемый объект представляет собой некую последовательность элементов, которую мы можем обойти с помощью итератора.  
К итерируемым объектам относятся строки, встроенные коллекции (кортежи, списки, множества, словари), объекты определенных классов (например, файлы) и даже сами итераторы.  
С итерируемыми объектами может работать конструкция `for X in Y`: она запрашивает итератор у `Y` и поочередно получает из этого итератора элементы, подставляя их вместо `X`.  
Большое количество функций (например, `sum`, `max`, `all`, `sorted`) могут принимать произвольные итерируемые объекты, что открывает широкие возможности для сокращения (некоторые из них будут рассматриваться в последующих пунктах).  
Некоторые функции (например, `zip` и `map`) возвращают итераторы, поэтому необходимо понимать следующую их особенность: итератор является "одноразовым" объектом, то есть из него можно получить последовательность элементов только один раз. При попытке повторного обхода он сразу сообщит, что элементов больше нет. С таким поведением можно было столкнуться при использовании функции `map`:
```python
a = map(int, ["1", "2", "3"])
print(sum(a)) # 6
print(sum(a)) # 0
```
Функция `range` возвращает итерируемый объект, а не итератор, поэтому его можно обходить несколько раз:
```python
a = range(4)
print(sum(a)) # 6
print(sum(a)) # 6
```

#### 14 Немного теории: генераторы
В Python есть специальный синтаксис для создания некоторых итерируемых объектов:
```python
# генератор списков (list comprehension)
[expr for_comprehension] # порождает список

# выражение-генератор (generator expression)
(expr for_comprehension) # порождает итератор

# генератор множеств (set comprehension)
{expr for_comprehension} # порождает множество

# генератор словарей (dict comprehension)
{expr:expr for_comprehension} # порождает словарь
```
`expr` - это произвольное выражение; `for_comprehension` - это несколько записанных подряд `for`-выражений (`for ... in ...`) и `if`-выражений (`if ...`), причем первым выражением обязательно должно быть `for`-выражение. Чаще всего `for_comprehension` состоит просто из одного `for`-выражения.  
Немного примеров для ясности:
```python
[x*x for x in range(5)] # порождает список [0, 1, 4, 9, 16]
[x for x in range(10) if x%2 == 1] # порождает список [1, 3, 5, 7, 9]
{x:x*x for x in range(5)} # порождает словарь {0:0, 1:1, 2:4, 3:9, 4:16}
[x+y for x in "abc" for y in "xy"] # порождает список ["ax", "ay", "bx", "by", "cx", "cy"]
```
Более интересные примеры:
```python
s = [input() for _ in ' ' * n] # прочитать n строк
u = [x for x in u if x != n] # удалить из u все вхождения элемента n
```

Если выражение-генератор передать в функцию единственным аргументом, то образуется две пары круглых скобок:
```python
all((x>0 for x in m)) # все элементы m положительны?
```
Специально в таком случае разрешено опускать одну пару:
```python
all(x>0 for x in m) # эквивалентно предыдущему выражению
```

#### 15 Кортежи
Выражение, где несколько выражений стоят через запятую, автоматически формируется в кортеж:
```python
x = 2, 3+6, 42 # x - кортеж из трёх элементов: 2, 9 и 42
y = 2, # y - кортеж из одного элемента 2
```
Поскольку кортеж является итерируемым объектом, то можно использовать это выражение в инструкции `for`, когда требуется выполнить одну и ту же операцию для нескольких значений:
```python
for x in 1, -1: ...
```
Если в range используется небольшая заранее известная константа, то короче выписать требуемые значения явно:
```python
for i in range(4): ... # 15 символов
for i in 0,1,2,3: ... # 14 символов
```

#### 16 Присваивание
У оператора присваивания есть следующая форма:
```python
target_list = iterable
```
где `target_list` - это последовательность выражений, разделенных запятыми, а `iterable` - произвольный итерируемый объект.  
Последовательность выражений `target_list` может состоять даже из одного элемента, но в этом случае надо поставить после этого элемента запятую.  
При таком присваивании элементы `iterable` присваиваются соответствующим элементам `target_list`. Разумеется, количество элементов в `target_list` должно быть равно количеству элементов в `iterable`. 
```python
a, b, c = x, y, z # a = x, b = y, c = z
a, b, c = "xyz" # a = "x", b = "y", c = "z"
a, b, c = range(3) # a = 0, b = 1, c = 2
a, = [1] # a = 1
a, b = b, a # меняем значения переменных a и b местами
a, b = b, a+b # казалось бы, причём тут Фибоначчи
```

Перед одним из элементов `target_list` может стоять звёздочка. Этот элемент станет списком из значений, которые не влезли в другие элементы `target_list`:
```python
a, b, *c, d, e = 1, 2, 3, 4, 5, 6, 7 # a = 1, b = 2, c = [3, 4, 5], d = 6, e = 7
```
Помеченная звездочкой переменная будет списком вне зависимости от типа `iterable` и от того, сколько в неё прилетает значений:
```python
a, b, *c, d, e = 1, 2, 3, 4 # a = 1, b = 2, c = [], d = 3, e = 4
a, b, *c, d, e = 1, 2, 3, 4, 5 # a = 1, b = 2, c = [3], d = 4, e = 5
a, b, *c, d, e = "1234567" # a = "1", b = "2", c = ["3", "4", "5"], d = "6", e = "7"
```

Элементом `target_list` может быть не только переменная, но и любое выражение, которому можно что-то присвоить: элемент коллекции, получаемый по индексу; срез (о них будет дальше) или даже другой `target_list` (тогда его надо заключить в круглые или квадратные скобки):
```python
a, (b, c), d = "12", "34", "56" # a = "12", b = "3", c = "4", d = "56"
```
Разумеется, во вложенном `target_list` также может присутствовать звёздочка:
```python
(*a,), *b = "123", "456", "789" # a = ["1", "2", "3"], b = ["456", "789"]
```

#### 17 Итератор в список
При необходимости прочитать последовательность чисел хочется написать следующий код:
```python
u = map(int, input().split())
```
Проблема в том, что `map` возвращает итератор, который разрешает только пробежаться по полученной последовательности чисел, причем всего один раз. В более сложных случаях приходится явно преобразовывать итератор в список:
```python
u = list(map(int, input().split())) # 32 символа
```
В таком случае можно использовать генератор списков вместо `map`:
```python
u = [int(x) for x in input().split()] # 31 символ
```
Однако звёздочка решает эту проблему короче:
```python
*u, = map(int, input().split()) # 28 символов
```

#### 18 `eval`/`exec`
Функция `eval` принимает строку и интерпретирует её как произвольное выражение Python, возвращая полученный результат.  
Это позволяет нестандартными способами решать некоторые задачи: вместо того, чтобы парсить считанную строку и производить некоторые вычисления с полученными данными (как и подразумевалось автором задачи), можно модифицировать саму строку, чтобы она обрела корректный Python-синтаксис и про-eval-ить её.  
Рассмотрим простой пример: в единственной строке находится два числа и требуется поделить первое на второе нацело.  
Обычное решение этой задачи:
```python
a, b = map(int, input().split())
print(a//b)
# 39 символов
```
Решение с помощью `eval`:
```python
print(eval(input().replace(' ', '//')))
# 37 символов
```
Если в строке есть лишние пробелы, то может помочь опциональный параметр `count` метода `replace`, задающий максимальное количество замен:
```python
print(eval(input().replace(' ', '//', 1))) # заменяем только первый пробел
```

Другим популярным применением функции `eval` является повторение одной инструкции. Рассмотрим некоторые интересные случаи.

1. Прочитать `n` строк:
    ```python
    s = [input() for _ in ' '*n] # 21 символ
    s = eval('input(),' * n) # 20 символов
    ```

2. Создать двухмерный массив (матрицу):
    ```python
    s = [[0] * n for _ in ' ' * n] # 19 символов
    s = eval('[0] * n,' * n) # 18 символов
    ```

При такой замене `s` получается кортежем вместо списка. Это редко бывает важно, однако ограничения всё же накладывает: например, во втором примере это ведёт к тому, что не выйдет заменить строку матрицы другим списком (сами элементы строк менять можно, разумеется).

Для парсинга дробных чисел используется `float`:
```python
float('2.4') == 2.4
```
Однако функция `eval` короче на один символ:
```python
eval('2.4') == 2.4
```
Приятный бонус: если входное число было без точки, то оно распарсится как `int`. Это бывает полезно при парсинге группы чисел, в которых целые и дробные перемешаны:
```python
n, *m = map(eval, '2 2.4 3.6'.split()) # n == 2 (целое), m == [2.4, 3.6] (дробные)
```

Функция `exec`, в отличие от `eval`, позволяет интерпретировать произвольный код, а не только выражение, но и значения не возвращает. На практике может быть применена только в специфических случаях.

#### 19 `map`, `zip`
Функция `map` может принимать несколько итерируемых объектов:
```python
map(max, [1, 20, 3], [10, 2, 30]) # 10, 20, 30
```
Функция `zip` позволяет сгруппировать элементы списка попарно:
```python
for x, y in zip(s[::2], s[1::2]): ... # 28 символов
```
Если `s` представляет собой итератор (например, является результатом вызова функции `map`), то, благодаря одноразовости извлечения каждого элемента из итератора, выражение упрощается до
```python
for x, y in zip(s, s): ...
```
Более того, с помощью функции `iter` можно получить итератор у любого итерируемого объекта (например, списка) `s`:
```python
k = iter(s)
for x, y in zip(k, k): ...
# 26 символов 
```
В случае, когда необходимо разбивать не на пары, а на тройки, становится выгодно использовать следующую конструкцию:
```python
for x, y, z in zip(*[iter(s)]*3): ... 
```
Использование `zip` для разбиения коллекции на группки не всегда оправдано, иногда можно использовать другой подход:
```python
while s:
    x, y, *s = s
    ...
```
Этот подход имеет квадратичную сложность, поэтому не рекомендуется для применения к большим коллекциям.

Другим вариантом использования `zip` является перебор всех пар соседних элементов коллекции:
```python
for x, y in zip(s, s[1:]): ...
```
Для этого варианта также существует краткая реализация без `zip`:
```python
x, *u = u
for y in u:
    ...
    x = y
```

#### 20 `open`
Обычно функцию `open` используют для открытия файлов:
```python
f = open("input.txt") # f - объект файла, связанный с файлом input.txt
```
В документации можно узнать, что `open` умеет работать с уже открытым файлом, для этого ей надо передать дескриптор этого файла. У стандартных потоков `stdin`, `stdout` и `stderr` есть свои дескрипторы - 0, 1 и 2 соответственно. Следовательно, мы можем написать
```python
f = open(0) # f - объект файла, связанный со стандартным входным потоком
```
и читать из стандартного входного потока, как из файла.

Объект файла является итератором, поэтому можно писать код вроде этого
```python
for s in open(0): ... # цикл по всем строкам файла
```
Однако чаще всего бывает нужно просто считать весь файл:
```python
*s, = open(0) # s - список строк файла
```
Достаточно часто в первой строке файла находится просто количество последующих строк. Поскольку мы и так считываем все строки, эту информацию можно проигнорировать:
```python
_, *s = open(0) # s - список строк файла кроме первой
```

К сожалению, `open`, в отличие от `input`, возвращает строки с символами перевода строки (если файл не заканчивается символом перевода строки, то последняя строка без перевода). Это не имеет значения, если в строках находятся числа (ведь они всё равно будут обрабатываться методом `split` или функцией `int`, которым безразличен лишний пробельный символ). Однако если нужно работать со строками именно как со строками, то придется избавиться от лишнего символа явно (например, с помощью метода `strip` или среза `[:-1]`).

У объекта файла есть метод `read`, который позволяет прочитать весь файл за раз, в одну строку. Например, если ввод содержит только числа и требуется все их считать, то можно написать
```python
map(int, open(0).read().split())
```

#### 21 Функции и методы
Функции в Python являются _объектами первого класса_, то есть ими можно оперировать как с обычными объектами. Поэтому мы можем передавать одни функции в качестве аргументов в другие функции (например, в `map`) или сохранять их в переменные:
```python
a = input()
b = input()
# 18 символов
```
сокращается до
```python
I = input
a = I()
b = I() 
# 17 символов
```
Методы классов на самом деле являются функциями, в которые первым аргументом передается объект, у которого был вызван метод: `obj.func(...)` эквивалентно `Type.func(obj, ...)`, где `Type` - класс объекта `obj`. Выражения вида `obj.func` и `Type.func`, так же как и обычные функции, являются объектами первого класса, то есть их можно сохранять в переменные
```python
u = str.replace
t = u(u(u(s, "a", "A"), "b", "B"), "c", "C")
```
и передавать в другие функции 
```python
map(str.split, open(0))
```
Например, таким образом можно реализовать replace для списков:
```python
map({2:5}.get, L, L) # заменяет в списке L все вхождения 2 на 5
```
или найти количество несовпадающих элементов в коллекциях:
```python
sum(map(str.__ne__, A, B)) # 24 символа
sum(a != b for a, b in zip(A, B)) # 25 символов
```

У встроенных типов есть большое количество перегруженных операторов (методов), благодаря которым можно на лету формировать новые функции (что бывает нужно при использовании `map`):
```python
s.__eq__ # функция, сравнивающая переданный аргумент с s
1 .__add__ # функция, увеличивающая переданный аргумент на 1
```
Пробел после `1` в последнем примере нужен, чтобы парсер Python воспринял цифру и точку как разные токены, а не как один токен `1.` (вещественное число).

#### 22 Множественное присваивание
Python позволяет совершать сразу несколько присваиваний одной инструкцией:
```python
expr1 = expr2 = ... = exprN = expr
```
эквивалентно
```python
temp = expr
expr1 = temp
expr2 = temp
...
exprN = temp
```
Приведём несколько примеров:
```python
a = b = c = 0 # создает три переменные a, b и c, равные нулю
x = y = [] # создает две переменные x и y, указывающие на один и тот же список
*x, = *y, = map(int, "1 2 3".split()) # создает списки x = [1, 2, 3] и y = []
```
Разберемся в причинах столь необычного поведения последнего примера. Как следует из вышесказанного, он эквивалентен
```python
temp = map(int, "1 2 3".split())
*x, = temp
*y, = temp
```
Итератор, возвращаемый функцией `map`, сохраняется во временную переменную `temp`. При выполнении первого присваивания `*x, = temp` выполняется пробег по итератору, то есть из него извлекаются все значения. Поэтому при выполнении второго присваивания `*y, = temp` итератор сразу сообщает, что он пуст, и `y` присваивается пустой список.

#### 23 Работа с коллекциями
Часто требуется создать пустую коллекцию:
```python
L = [] # пустой список
L = {} # пустой словарь
L = set() # пустое множество
```
Создание пустого множества занимает целых 7 символов. Однако иногда можно создать множество из одного элемента, например, если этот элемент все равно будет добавлен позже либо если он не повлияет на логику программы:
```python
L = {0} # множество из одного элемента 0
```

Чтобы добавить элемент в конец списка принято использовать следующую конструкцию:
```python
L.append(x) # 11 символов
```
Однако добавлять список к списку намного короче, поэтому сформируем из элемента `x` список и прибавим его к `L`:
```python
L += [x] # 6 символов
```
Теперь заметим, что операция `+=` поддерживает добавление не только списка, а вообще любого итерируемого объекта, поэтому будем добавлять кортеж вместо списка: 
```python
L += x, # 5 символов
```
А для добавления элемента в начало списка можно написать
```python
L = [x]+L
```

У множеств также можно использовать перегруженные операторы вместо методов:
```python
S |= {x} # добавить x в S
S -= {x} # удалить x из S
S -= S # очистить S
```
У множеств вообще много операторов, но хотелось бы упомянуть необычные операторы сравнения множеств:
```python
A <= B # является ли A подмножеством B
A < B # является ли A подмножеством B, причем A != B
```
Например, их можно использовать для проверки того, что строка состоит только из заданных символов:
```python
set(s) <= set(t) # строка s состоит только из символов строки t
```
В качестве обратной операции можно использовать вычитание:
```python
set(s) - set(t) # символы строки s, не входящие в строку t
if set(s) - set(t): ... # если строка s состоит не только из символов строки t
```

У списков и кортежей также перегружен оператор сравнения, поэтому их можно сортировать.

У словарей есть очень полезный метод `get`:
```python
D.get(x, y) # вернуть D[x], если такой элемент есть в словаре, иначе вернуть y
```
Если ключами словаря являются строки, то может быть короче использовать именованные аргументы (keyword arguments):
```python
{'a':1, 'b':4, 'c':9} # 19 символов
dict(a=1, b=4, c=9) # 17 символов
```

Использование звёздочки позволяет распиливать список на части:
```python
a, *T = L # a = L[0], T = L[1:]
*T, a = L # a = L[-1], T = L[:-1] (все элементы, кроме последнего)
```
Несколько интересных частных случаев:
```python
# Получить последний элемент списка
a = L[-1] # 7 символов
*_, a = L # 6 символов

# Извлечь последний элемент
a = L.pop() # 9 символов
*L, a = L # 6 символов

# Извлечь первый элемент
a = L.pop(0) # 10 символов
a, *L = L # 6 символов

# Получить первый элемент списка либо y, если список пуст
a = L and L[0] or y # 13 символов
a = (L+[y])[0] # 12 символов
a, *_ = L+[y] # 10 символов
```
Важно отметить, что инструкции со звёздочкой создают новые списки вместо использования/модификации старых, поэтому являются неэффективными.

#### 24 Срезы (slice)
Срезы работают для строк, списков и кортежей (причем срез строки - тоже строка, срез списка - список, срез кортежа - кортеж).  
Самый известный пример применения срезов - это разворот:
```python
m[::-1]
```
Благодаря этому можно кратко проверить, является ли строка палиндромом: 
```python
s == s[::-1]
```

В задачах часто требуется вывести ту или определенную строку в зависимости от некоторого условия. Пользуясь пунктом об условных операторах, можно предложить два разных решения:
```python
c and 'NO' or 'YES' # 15 символов
['YES', 'NO'][c] # 15 символов
```
Срезы дают третье решение:
```python
'YNEOS'[c::2] # 13 символов
```

Если индексы срезов выходят за границы коллекции, то просто возвращается пустая коллекция. Это позволяет использовать их для проверки длины коллекции в условных операторах:
```python
if len(s) > n: ... # 11 символов
if s[n:]: ... # 8 символов
```
а также для безопасного извлечения символа из строки:
```python
s[i] # если выход за границы - возникает исключение IndexError
s[i:i+1] # если выход за границы - возвращается пустая строка
```

Для изменяемых (mutable) коллекций (например, списков) можно модифицировать срезы, при этом меняться будет и исходная коллекция. Для удобства во всех примерах положим `A = [0, 1, 2, 3, 4]`.
```python
A[i:j] = B # заменить элементы среза на элементы итерируемого объекта B
A[2:4] = 9, 8, 7 # A = [0, 1, 9, 8, 7, 4]

A[:i] += B # вставка элементов итерируемого объекта B в i-ую позицию
A[:2] += 7, 7 # A = [0, 1, 7, 7, 2, 3, 4]

A[:i] += x, # вставка элемента x в i-ую позицию 
A[:2] += 7, # A = [0, 1, 7, 2, 3, 4]

A[i:j] *= k # размножить срез в коллекции
A[2:4] *= 3 # A = [0, 1, 2, 3, 2, 3, 2, 3, 4]

del A[i:j] # удалить элементы среза из A
del A[2:4] # A = [0, 1, 4]

A[i:j:k] = B # заменить элементы среза на элементы итерируемого объекта B
             # len(A[i:j:k]) должно быть равно len(B)
A[1::2] = 9, 9 # A = [0, 9, 2, 9, 4]

del A[i:j:k] # удалить элементы среза из A
del A[::2] # A = [1, 3]
```

#### 25 Вывод
Пусть требуется вывести список чисел через пробел. Наивное решение этой задачи выглядит так:
```python
print(' '.join(map(str, m))) # 26 символов
```
Однако лучше написать так:
```python
print(*m) # 9 символов
```
Оператор `*` распаковывает элементы произвольного итерируемого объекта в аргументы функции. В данном случае он распаковывает элементы списка `m` в функцию `print`, которая, как известно, выводит переданные ей аргументы через пробел.

У метода `print` есть параметры `sep` и `end`.  
Параметр `sep` определяет, чем разделяются аргументы. По умолчанию `sep` равен пробелу.
```python
u = [2, 3, 4]
print(*u) # выведет "2 3 4"
print(*u, sep=', ') # выведет "2, 3, 4"
```
Параметр `end` определяет, чем завершается вывод. По умолчанию `end` равен переводу строки.
```python
print(s) # выведет s с переводом строки
print(s, end='') # выведет s без перевода строки
print(end=s) # выведет s без перевода строки
```
Параметры `sep` и `end` должны быть строками, поэтому последний пример применим только если `s` является строкой.

Если вывод нетривиальный, можно использовать оператор `%` вместо ручного формирования вывода или метода `format`:
```python
print("Red: ", x, ", green: ", y, ", blue: ", z, ".", sep="") # 49 символов
print("Red: {}, green: {}, blue: {}.".format(x, y, z)) # 47 символов
print("Red: %d, green: %d, blue: %d." % (x, y, z)) # 41 символ
```
Этот оператор может оказаться полезен даже в очень простых случаях:
```python
'('+s+')' # 9 символов
'(%s)' % s # 8 символов 
```

На самом деле тестирующему серверу почти во всех задачах безразлично, какими пробельными символами и в каком количестве разделены выводимые данные. Например, если в задаче требуется вывести числа через пробел, то можно спокойно выводить каждое число в отдельной строке, используя `print`.

#### 26 Оператор `in`
Оператор `in` предназначен для проверки наличия элемента в итерируемом объекте:
```python
2 in [2, 3, 4] # True
2 in range(5) # True
```
Однако у него есть еще одно полезное предназначение - проверка вхождения подстроки в строку:
```python
"bc" in "abcd" # True
```

#### 27 Стандартные функции
У некоторых стандартных функций есть параметры по умолчанию, которые могут быть полезны в деле сокращения. Выше уже приводился пример функции `print` с параметрами `sep` и `end`. Рассмотрим еще несколько примеров:

1. У функций `min`, `max`, `sorted` и метода `list.sort` есть опциональный параметр `key`. Он задаёт функцию, которая извлекает из элемента ключ, по которому и будет производится сравнение. Например, результатом `min(["2", "11"], key=int)` будет `"2"`, потому что `int("2") < int("11")`.
2. У конструктора типа `int` есть опциональный параметр `base`, задающий систему счисления:
    ```python
    int("DEAD", 16) # 57005
    int("2011", 3) # 58
    int("python", 36) # 1570137287
    ```
    В частности, это можно использовать для более сжатого хранения чисел:
    ```python
    # 96 символов - массив предпосчитанных значений
    u = [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790]
    
    # 82 символа - тот же массив, сжатый в строку 36-разрядных чисел
    u = [int(x, 36) for x in '1 1 2 5 E 16 3O BX 13Q 3R2 CYK 19CY 4GI4 FX84 1LBM0 5RSL9 L1U5I 256QK6'.split()]
    ```
    К сожалению, столь же мощной обратной функции нет, только несколько частных: `hex`, `oct` и `bin`, преобразующие в 16-, 8- и 2-чные системы счисления соответственно.
3. У функции `sum` есть параметр `start`, который указывает, с какого значения начнется суммирование (по умолчанию равен `0`).  
    Это можно использовать, если вам вдруг понадобилось преобразовать список списков в список (другими словами, сложить списки):
    ```python
    sum(l, [])
    ```
    К сожалению, строки так складывать запрещено, приходится использовать `''.join`. 
4. У функции `pow` есть опциональный третий параметр, который задаёт модуль, по которому будут производиться вычисления.
    ```python
    pow(x, y, z) == x**y % z
    ```
    Хотя вызов `pow` длиннее аналогичной записи на операторах, он производит вычисления эффективно, что иногда может оказаться важным.
5. В функцию `input` можно передать опциональный параметр, который будет выведен перед началом чтения:
    ```python
    s = input(x) # эквивалентно print(x, end=''); s = input()
    ```

#### 28 Оператор `**`
Оператор `**` выполняет возведение в степень, причём если аргументами были `int`, возвращается тоже `int`:
```python
3**4 == 81
```
Но если требуется возвести переменную в квадрат, `x*x` оказывается короче `x**2`.  
С помощью данного оператора можно находить корень числа без подключения модуля `math`:
```python
49 ** .5 == 7.0
```

Также этот оператор может быть применён для сокращенного объявления констант:
```python
1000000007 # 10 символов
10**9 + 7 # 7 символов
```
Иногда требуется задать какую-то константу, которая была бы заведомо больше какого-то числа (например, для создания списка через `[0] * n`). Несколько примеров:
```python
10**4 == 10000 # 5 символов
5**6 == 15625 # 4 символа

10**5 == 100000 # 5 символов
7**6 == 117649 # 4 символа
```
Впрочем, если не требуется целочисленность, то для этой задачи подойдет обычный экспоненциальный формат, например, `1e9`.

#### 29 Комплексные числа
В геометрических задачах часто возникает задача вычисления корня из суммы двух квадратов.  
Обычно это пишут так:
```python
(a*a + b*b)**.5 # 13 символов
((a-c)**2 + (b-d)**2)**.5 # 23 символа
```
Но лучше использовать комплексные числа:
```python
abs(a + b*1j) # 11 символов
abs(a-с + (b-d)*1j) # 18 символов
```
Если требуется найти расстояние между точками, заданными кортежем/списком из двух чисел, то может быть удобно конструировать комплексные числа иначе:
```python
c = complex
r = abs(c(*x)-c(*y))
```

Комплексные числа вообще удобно использовать в геометрии - это на самом деле готовый класс для точек или векторов: их можно складывать, вычитать, умножать на константу, поворачивать и т.д. Рассмотрим несколько интересных случаев.  
Как уже упоминалось выше, если мы будем хранить точки комплексными числами, расстояние между ними можно вычислить как модуль разности: `abs(a - b)`.  
В задачах на графы иногда возникает необходимость обхода двумерного массива (например, волновым поиском). При этом приходится отписывать 4 варианта: идём вправо, вверх, влево, вниз. Если же хранить текущую позицию комплексным числом, то это можно записать так:
```python
for d in 1, 1j, -1, -1j:
    f(x+d)
# 24 символа
```
Умножение на `1j` поворачивает вектор на 90 градусов против часовой стрелки (а на `-1j` - по часовой). Это полезно для реализации поворотов налево/направо, а также может быть использовано для сокращения вышеприведенного кода:
```python
d = 1
for _ in '    ':
    f(x+d)
    d *= 1j
 # 23 символа
```
При использовании комплексных чисел очень длинно получать координаты из комплексного числа: `z.real`, `z.imag`. Следовательно, следует свести получение координат к минимуму, пытаясь производить все вычисления в комплексных числах. Однако если мы работаем с двумерным массивом, то необходимость получать координаты возникает при каждом обращении к массиву. Эту проблему можно попробовать решить заменой двумерного массива на словарь (`dict`) с комплексными числами в качестве ключа. К сожалению, такой подход может сильно увеличить потребление памяти.

#### 30 `import`
Если импортируемые из модуля объекты используются более одного раза или имя модуля состоит не менее чем из 5 символов, то выгодно использовать инструкцию `from module import *` вместо `import module`:
```python
import math
y = math.sin(x) + math.cos(x)
# 35 символов

from math import *
y = sin(x) + cos(x)
# 30 символов
```

Инструкция импорта позволяет импортировать сразу несколько модулей:
```python
import re, math
```

#### 31 Стек через односвязный список
В качестве стека принято использовать список:
```python
q = [] # пустой стек
if q: # проверка стека на наличие элементов
q += b, # добавление элемента
q[-1] # последний элемент
*q, b = q # извлечение элемента (неэффективно, 6 символов)
q.pop() # извлечение элемента (эффективно, 7 символов)
```
Но реализация стека через односвязный список может оказаться короче:
```python
q = 0 # пустой стек
if q: # проверка стека на непустоту
q = q, b # добавление элемента
q[1] # последний элемент
q, b = q # извлечение элемента (эффективно, 5 символов)
```
Разумеется, при такой реализации уже нельзя кратко пробежаться по стеку и эффективно обратиться к элементу по индексу.

#### 32 Одномерные массивы вместо двумерных
Достаточно часто оказывается короче использовать одномерные массивы вместо двумерных. Разберём несколько сценариев использования.  
Создание одномерного массива гораздо короче создания двумерного:
```python
M = [[0]*m for _ in ' '*n]
M = n*m * [0]
```
Чтобы пробежаться по одномерному массиву, нужен один цикл вместо двух. Причём это оказывается короче пробега по двумерному массиву, даже если необходимо знать текущие индексы:
```python
for i in range(n):
    for j in range(m):
     ...
# 30 символов

for k in range(n*m):
    i = k//m
    j = k%m
    ...
# 28 символов
```
Индексация в одномерном длиннее всего на один символ:
```python
M[i][j] # 7 символов
M[i*m+j] # 8 символов
```
Но при одномерном подходе есть возможность использовать одномерную индексацию `M[k]`, которая занимает всего 4 символа. В такой одномерной индексации оказывается короче переходить к соседним ячейкам массива:
```python
M[i][j] # текущая
M[i][j+1] # правая от текущей
M[i+1][j] # нижняя от текущей

M[k] # текущая
M[k+1] # правая от текущей
M[k+m] # нижняя от текущей
```
Для хранения текущей позиции в одномерном массиве нужно одно число, а в двухмерном - два.  
В двумерных массивах строки выражены явно, для получения списка столбцов можно использовать выражение `zip(*M)`. В одномерных массивах строки и столбцы можно получать по индексу с помощью срезов:
```python
M[i*m:i*m+m] # i-я строка
M[j::m] # j-й столбец
```
Таким образом, код для одномерного и двумерного подходов сильно отличается, поэтому лучше всего попробовать оба варианта и посмотреть, какой выйдет короче в данной конкретной задаче.

Важный класс задач на двумерные массивы - это задачи, в которых есть некая карта и по этой карте необходимо перемещаться (поиском в ширину, заливкой, поиском в глубину, ...). В таких задачах обычно имеются запретные клетки, в которые нельзя двигаться. При движении нельзя выходить за границы карты, поэтому приходится при проверке возможности перехода прописывать множество условий примерно следующего вида:
```python
if i: f(i-1, j)
if j: f(i, j-1)
if i<n-1: f(i+1, j)
if j<m-1: f(i, j+1)
```
Проблема обостряется в свете переписывания с двумерного массива на одномерный: для проверок нужны индексы в явном виде, а на их получение при одномерном подходе тратятся дополнительные символы.  
Обычным способом избавления от этих проверок является создание дополнительного слоя запретных клеток вокруг имеющейся карты. В результате алгоритм не выходит за границы карты, потому что она окружена запретными клетками.  
В Python этот способ работает еще лучше благодаря допустимости отрицательных индексов. Например, при добавлении запретных клеток справа от карты, мы автоматически получаем запретные клетки слева от карты: перед индексом `0` находится индекс `-1`, который указывает на конец массива, то есть на правую границу карты, которая состоит из запретных блоков! Аналогично, добавив запретные клетки снизу от карты, мы автоматически получаем верхнюю границу.  
Карта часто выдаётся в виде списка строк. Если прочитать их через `open`, то в конце каждой строки окажется символ `'\n'`. Если при написании кода считать запретными все клетки, не содержащие определённый символ (например, точку), то правая (и, соответственно, левая) граница возникает автоматически. Для завершения границ карты остается добавить строку с запретными символами в конец списка строк.  
После избавления от проверок перебор возможных движений при одномерном подходе превращается примерно в следующее:
```python
for d in 1, m, -1, -m:
    f(k+d)
```

#### 33 Регулярные выражения
Типичные регулярные выражения содержат большое количество обратных слешей (`\ `), которые приходится экранировать. Для решения этой проблемы в Python были введены raw строки, в которых `\ ` интерпретируется как обычный символ:
```python
"\\w+\\s+\\1" # 13 символов, обычная строка
r"\w+\s+\1" # 11 символов, raw строка
```

Иногда возникает необходимость задать поведение регулярного выражения, например, игнорирование регистра. Документация предоставляет набор флагов, для данного случая подходит `re.I` (сокращенная версия `re.IGNORECASE`). Однако эти флаги на самом деле являются просто числами:
```python
print(re.I) # печатает 2
```
То есть, вместо передачи флага можно передать его численное значение. Бонусом получаем более краткое комбинирование флагов:
```python
re.I | re.M # 9 символов
I | M # 3 символа (требует импорта имён из re)
2 | 8 # 3 символа (не требует импорта имён)
10 # 2 символа
```

Функция `match` проверяет, что некоторый префикс (начало) строки соответствует заданному шаблону. Чтобы проверить на соответствие шаблону строку целиком, предлагается использовать функцию `fullmatch`. Однако, символ `$` в конце шаблона позволяет добиться нужного эффекта и для функции `match`:
```python
fullmatch('[a-h]\d-[a-h]\d', s) # 30 символов
match('[a-h]\d-[a-h]\d$', s) # 27 символов
```

Второй аргумент функции `sub` указывает, на что заменяются подходящие под шаблон подстроки. В качестве этого аргумента можно передавать не только строку, но и функцию, которая для находимых подстрок должна определять на что они заменятся.

#### 34 `str.translate`
Метод `str.translate` заменяет все вхождения заданных символов на другие символы либо строки. Замена задаётся словарём, причём в качестве ключа требуется указывать код заменяемого символа:
```python
"data".translate({97: "aaa"}) == "daaataaa" # 97 - код символа 'a'
```
Метод позволяет производить несколько замен одновременно:
```python
"password".translate({97: "@", 111: "0", 115: "$"}) == "p@$$w0rd"
```
Если значением является односимвольная строка, то вместо неё можно написать код этого символа:
```python
"password".translate({97: 64, 111: 48, 115: 36}) == "p@$$w0rd" # эквивалентно предыдущему примеру
```
Если требуется удалить символ, то в качестве значения лучше указывать пустую строку вместо рекомендуемого в документации `None`:
```python
"what".translate({97: "u", 104: ""}) == "wut"
```
Возникающие после замены символы не обрабатываются, то есть новой замены для них не производится, поэтому можно заменять символы друг на друга:
```python
"abcd".translate({97: "b", 98: "a"}) == "bacd"
```
Замену можно задавать не только словарём, но и любым объектом, поддерживающим индексацию (например, списком или строкой):
```python
"abcd".translate("                                                                                                 ba") == "bacd"
```
В этой строке символ `b` стоит на 97 позиции, а символ `a` - на 98. Но при таком подходе, во-первых, количество пробельных символов может оказаться слишком большим, во-вторых, все символы, меньше `a`, заменятся на пробелы.

#### 35 `hashable`
Встроенные изменяемые коллекции (список, множество или словарь) не могут являться ключом словаря или элементом множества (потому что они изменяемые и для них невозможно эффективно поддерживать хэш). В таких случаях приходится использовать неизменяемые коллекции - `frozenset` вместо `set` и `tuple` вместо `list`.

#### 36 `pass`
В Python принято писать `pass` в местах, где синтаксис требует какое-то выражение, но писать нечего. Вместо `pass` можно написать любое другое выражение, например `0`:
```python
try: ...
except: 0 # подавляем все исключения
```

#### 37 Используем побочные эффекты
Обычно `map` рассматривают как способ сгенерировать новую последовательность по уже имеющейся. Функция, передаваемая в `map`, рассматривается просто как некоторый конвертер из старого значения в новое. Но можно передать функцию, которая сама по себе будет выполнять некоторую полезную работу:
```python
map(print, L) # выводит все элементы L (на самом деле нет!)
```
Этот код ничего не выведет, потому что функция `map` ленива: так как мы не используем результат её вызова, она не проделывает ни одной итерации. Требуется явно проитерироваться по возвращаемому ей результату. Самый короткий способ сделать это - поискать в нём элемент, которого там заведомо нет:
```python
0 in map(print, L) # выводит все элементы L
```
Полученный код на 1 символ короче аналогичного цикла:
```python
for x in L: print(x)
```

Если в итераторе поискать элемент, который там есть, то он остановится сразу после искомого элемента:
```python
z = iter(range(7)) # z - итератор на последовательность 0, 1, 2, 3, 4, 5, 6
3 in z # бежит по итератору, пока не встретится 3
print(*z) # выводит "4 5 6"
```

#### 38 `bytes`
Подобно тому, как строки являются неизменяемой коллекцией односимвольных строк, `bytes` является неизменяемой коллекцией однобайтовых чисел:
```python
l = b"golf"
list(l) # [103, 111, 108, 102]
l[2] # 108
108 in l # True
max(l) # 111
```
Иногда это можно использовать для краткой записи списка однобайтовых чисел. Если числу не соответствует никакой ASCII-символ, то его можно записать с помощью экранирования, например для `128` это будет `b'\x80'` или `b'\200'`.
```python
# первые десять чисел Фибоначчи
s = [1,1,2,3,5,8,13,21,34,55] # 27 символов
s = b'\1\1\2\3\5\b\r\25"7' # 24 символа
```

#### 39 Неожиданный `else`
У циклов `for` и `while` есть блок `else`, который выполняется, если цикл завершился естественным образом, а не через `break`.
```python
for x in L: # выводим первое положительное число в L
    if x > 0:
        print(x)
        break 
else: # либо -1, если таких нет
    print(-1)
```
Также блок `else` есть у инструкции `try`: он исполняется, если исключение не возникло.

#### 40 Глобальные переменные
При попытке присвоить значение глобальной переменной внутри функции просто создаётся локальная переменная с таким именем.  
Присвоение внутри функции по умолчанию присваивает значение локальной переменной функции, даже если глобальная переменная с таким именем уже есть. Если требуется изменить именно глобальную переменную, то нужно явно об этом сообщить:
```python
k = 5
def f():
    global k
    k = 6
f() 
print(k) # выводит "6"
# 31 символ
```
Однако обращаться к глобальным переменным (и даже модифицировать их, если они изменяемые) разумеется не запрещено, поэтому можно попробовать использовать список из одного элемента вместо самого элемента:
```python
k = [5]
def f():
    k[0] = 6
f() 
print(*k) # выводит "6"
# 30 символов
```
